<!doctype html><html lang=en><head><title>How to detect Errors in JavaScript :: Julian Dax</title><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="TL/DR Finding out if an object is an error is unreliable and full of edge-cases. A modern, isomorphic way to do it is the following1:
function isError (object) { return object instanceof Error || ( object?.constructor?.name === &amp;#39;Error&amp;#39; || object?.constructor?.name === &amp;#39;DOMException&amp;#39; ) } Many custom error classes in the JavaScript ecosystem are hard to detect because creating custom error classes used to be hard before the introduction of the class syntax."><meta name=keywords content=","><meta name=robots content="noodp"><link rel=canonical href=https://juliand.ax/posts/detect-js-errors/><link rel=stylesheet href=https://juliand.ax/styles.css><link rel="shortcut icon" href=https://juliand.ax/img/theme-colors/orange.png><link rel=apple-touch-icon href=https://juliand.ax/img/theme-colors/orange.png><meta name=twitter:card content="summary"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="How to detect Errors in JavaScript"><meta property="og:description" content="TL/DR Finding out if an object is an error is unreliable and full of edge-cases. A modern, isomorphic way to do it is the following1:
function isError (object) { return object instanceof Error || ( object?.constructor?.name === &amp;#39;Error&amp;#39; || object?.constructor?.name === &amp;#39;DOMException&amp;#39; ) } Many custom error classes in the JavaScript ecosystem are hard to detect because creating custom error classes used to be hard before the introduction of the class syntax."><meta property="og:url" content="https://juliand.ax/posts/detect-js-errors/"><meta property="og:site_name" content="Julian Dax"><meta property="og:image" content="https://juliand.ax/"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><meta property="article:published_time" content="2023-03-31 19:16:51 +0200 +0200"></head><body><div class="container headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>Julian Dax</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/profile>Profile</a></li><li><a href=/showcase>Showcase</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/profile>Profile</a></li><li><a href=/showcase>Showcase</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=https://juliand.ax/posts/detect-js-errors/>How to detect Errors in JavaScript</a></h1><div class=post-meta><time class=post-date>2023-03-31 ::</time></div><span class=post-tags>#<a href=https://juliand.ax/tags/javascript/>JavaScript</a>&nbsp;
#<a href=https://juliand.ax/tags/errors/>Errors</a>&nbsp;</span><div class=post-content><div><h2 id=tldr>TL/DR<a href=#tldr class=hanchor arialabel=Anchor>&#8983;</a></h2><p>Finding out if an object is an error is unreliable and full of edge-cases. A modern,
<a href=https://en.wikipedia.org/wiki/Isomorphic_JavaScript>isomorphic</a> way to
do it is the following<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>isError</span> (<span style=color:#a6e22e>object</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>object</span> <span style=color:#66d9ef>instanceof</span> Error <span style=color:#f92672>||</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>object</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>constructor</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;Error&#39;</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>object</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>constructor</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;DOMException&#39;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Many custom error classes in the JavaScript ecosystem are hard to detect
because creating custom error classes used to be hard before the introduction
of the <code>class</code> syntax.</p><h2 id=part-one-wtf-is-an-error-anyway>Part One: WTF is an error anyway?<a href=#part-one-wtf-is-an-error-anyway class=hanchor arialabel=Anchor>&#8983;</a></h2><p>In JavaScript different things can be meant by &ldquo;error&rdquo;. This part
discusses the different kinds of errors.</p><h3 id=native-errors>Native Errors<a href=#native-errors class=hanchor arialabel=Anchor>&#8983;</a></h3><p>The <a href=https://tc39.es/ecma262/#sec-error-objects>JavaScript
specification</a> defines a
number of &ldquo;Native Errors&rdquo; which are all <code>instanceof Error</code>. According to
the specification, these errors are marked in a way that is not
accessible from JavaScript itself<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. However, in practice they can be
<a href=#is-native-error>detected reliably</a> in Node.js and <a href=#to-string>unreliably in the
browser</a>.</p><h3 id=domexceptions>DOMExceptions<a href=#domexceptions class=hanchor arialabel=Anchor>&#8983;</a></h3><p><code>DOMException</code>s<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> are errors that are thrown when an error
happens in one of the web APIs. It is defined in the <a href=https://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-17189187>DOM
specification</a>.
DOMExceptions are no native errors and are not <code>instanceof Error</code>.
The <code>DOMException</code> class does exist both in the browser and in Node.js.</p><h3 id=instances-of-error>Instances of <code>Error</code><a href=#instances-of-error class=hanchor arialabel=Anchor>&#8983;</a></h3><p>There are a lot of custom errors defined in popular libraries that are
not native but still instances of <code>Error</code>. This happenes if the
prototype of the error object is manually set to <code>Error.prototype</code>.</p><h3 id=objects-with-a-constructor-named-error>Objects with a constructor named &ldquo;Error&rdquo;<a href=#objects-with-a-constructor-named-error class=hanchor arialabel=Anchor>&#8983;</a></h3><p>If an object crosses a <a href=https://tc39.es/ecma262/#realm>realm boundary</a>
<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup>, it is not instance
of anything in the current realm. However, the name of the constructor
is still <code>"Error"</code>.</p><h3 id=objects-with-the-string-properties-name-and-message>Objects with the <code>string</code> properties <code>name</code> and <code>message</code><a href=#objects-with-the-string-properties-name-and-message class=hanchor arialabel=Anchor>&#8983;</a></h3><p>For TypeScript, an <code>Error</code> is any object that conforms to <a href=https://github.com/microsoft/TypeScript/blob/4b6fb95f040c5c81743e19a56df8fa99bf3d139f/lib/lib.es5.d.ts#L1052>this
interface</a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-TypeScript data-lang=TypeScript><span style=display:flex><span><span style=color:#66d9ef>interface</span> Error {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>name</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>message</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>stack?</span>: <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The optional <code>stack</code> property is not defined in the standard but present
in every modern JavaScript engine.</p><h2 id=part-two-how-to-check-for-errors>Part Two: How to Check for Errors<a href=#part-two-how-to-check-for-errors class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=detecting-native-errors>Detecting Native Errors<a href=#detecting-native-errors class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Clever people came up with a way to check for native errors by using the
<code>Object.prototype.toString()</code> method:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span>Object.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>toString</span>.<span style=color:#a6e22e>call</span>(<span style=color:#66d9ef>new</span> Error()) <span style=color:#75715e>// returns &#39;[object Error]&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Object.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>toString</span>.<span style=color:#a6e22e>call</span>({}) <span style=color:#75715e>// returns &#39;[object Object]&#39;
</span></span></span></code></pre></div><p>Objects marked as errors are <em>used to be</em> the only ones for which
<code>Object.prototype.toString.call()</code> would return <code>[object Error]</code> instead
of <code>[object Object]</code>. However, this is no longer the case since the
introduction of
<a href=https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toStringTag><code>Symbol.toStringTag</code></a>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>fakeError</span> <span style=color:#f92672>=</span> {[<span style=color:#a6e22e>Symbol</span>.<span style=color:#a6e22e>toStringTag</span>]<span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Error&#39;</span>};
</span></span><span style=display:flex><span>Object.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>toString</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>fakeError</span>) <span style=color:#75715e>// returns &#39;[object Error]&#39;
</span></span></span></code></pre></div><p>Therefore, there can be <em>false positives</em> when checking with
<code>Object.prototype.toString.call()</code>.</p><p>There are two other reasons for not using this method: firstly, using
<code>Object.prototype.toString.call()</code> for type testing is discouraged <a href=https://tc39.es/ecma262/#sec-object.prototype.tostring>in
the
specification</a>.
And secondly, many custom errors and <code>DOMException</code> will not return
<code>[object Error]</code> when checked like this:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#75715e>// I&#39;m using AxiosError as an example for an error that is not a native error.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// I don&#39;t want to pick on Axios; this is very common.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> {<span style=color:#a6e22e>AxiosError</span>} <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;axios&#34;</span>;
</span></span><span style=display:flex><span>Object.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>toString</span>.<span style=color:#a6e22e>call</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>AxiosError</span>()); <span style=color:#75715e>// returns &#39;[object Object]&#39;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Object.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>toString</span>.<span style=color:#a6e22e>call</span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>DOMException</span>()); <span style=color:#75715e>// returns &#39;[object DOMException]&#39;
</span></span></span></code></pre></div><p>Thus, <em>False negatives</em> will also happen quite regularly when using this
method.</p><p>Because of all these problems, the Node.js developers decided to expose
the V8-internal <code>IsNativeError()</code> function as
<a href=https://nodejs.org/api/util.html#utiltypesisnativeerrorvalue><code>util.types.isNativeError()</code></a>.
This gives you a reliable way to check if a value is marked as an error.
However, since many custom error values are not marked, this way of
checking will still produce many false negatives.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#a6e22e>util</span>.<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>isNativeError</span>({[<span style=color:#a6e22e>Symbol</span>.<span style=color:#a6e22e>toStringTag</span>]<span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;Error&#39;</span>}) <span style=color:#75715e>// returns false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>util</span>.<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>isNativeError</span>(<span style=color:#66d9ef>new</span> Error()) <span style=color:#75715e>// returns true
</span></span></span></code></pre></div><p><strong>I recommend not checking if an error is native. There are too many
false negatives and cross-realm checking can be done using constructor
names.</strong></p><h3 id=detecting-error-instances>Detecting <code>Error</code> instances<a href=#detecting-error-instances class=hanchor arialabel=Anchor>&#8983;</a></h3><p>Another way of checking if something is an error is using the
<code>instanceof</code> operator. It is quite common for errors to be
<code>instanceof Error</code> but not native, so this will catch more errors than
the methods described above. It also finds <code>DOMException</code>s as they are also
<code>instanceof Error</code>. It is also faster than most other methods as <code>instanceof</code>
is quicker than property access. However, as already mentioned, this does
not work across realms:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span>(<span style=color:#66d9ef>new</span> Error()) <span style=color:#66d9ef>instanceof</span> Error; <span style=color:#75715e>// returns true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>(<span style=color:#66d9ef>new</span> <span style=color:#a6e22e>DOMException</span>()) <span style=color:#66d9ef>instanceof</span> Error; <span style=color:#75715e>// returns true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>context</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>createContext</span>({});
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>myError</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>runInContext</span>(<span style=color:#e6db74>&#39;new Error()&#39;</span>, <span style=color:#a6e22e>context</span>); <span style=color:#75715e>// creates an error in a different realm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myError</span> <span style=color:#66d9ef>instanceof</span> Error; <span style=color:#75715e>// returns false
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>util</span>.<span style=color:#a6e22e>types</span>.<span style=color:#a6e22e>isNativeError</span>(<span style=color:#a6e22e>myError</span>); <span style=color:#75715e>// returns true
</span></span></span></code></pre></div><p>To detect errors from other realms we can check the constructor name.
This may lead to false positives though:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span>(<span style=color:#66d9ef>new</span> Error()) <span style=color:#66d9ef>instanceof</span> Error; <span style=color:#75715e>// returns true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>context</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>createContext</span>({});
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>myError</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>runInContext</span>(<span style=color:#e6db74>&#39;new Error()&#39;</span>, <span style=color:#a6e22e>context</span>); <span style=color:#75715e>// creates an error in a different realm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>myError</span>.<span style=color:#a6e22e>constructor</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;Error&#34;</span>; <span style=color:#75715e>// returns true
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>{<span style=color:#a6e22e>constructor</span><span style=color:#f92672>:</span> {<span style=color:#a6e22e>name</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;Error&#34;</span>}}.<span style=color:#a6e22e>constructor</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;Error&#34;</span>; <span style=color:#75715e>// returns true
</span></span></span></code></pre></div><p>However, the example for the false positive is contrived and if people
really want to fake an error, they probably have reasons for it.</p><h3 id=checking-for-message-and-name>Checking for <code>message</code> and <code>name</code><a href=#checking-for-message-and-name class=hanchor arialabel=Anchor>&#8983;</a></h3><p>If TypeScript&rsquo;s error definition is good enough for you, this type guard
will do the job:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-TypeScript data-lang=TypeScript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>isError</span>(<span style=color:#a6e22e>e</span>: <span style=color:#66d9ef>unknown</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>e</span> <span style=color:#66d9ef>is</span> Error {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>e</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;object&#34;</span> <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>e</span>[<span style=color:#e6db74>&#34;name&#34;</span>] <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;string&#34;</span>) <span style=color:#f92672>&amp;&amp;</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>typeof</span> <span style=color:#a6e22e>e</span>[<span style=color:#e6db74>&#34;message&#34;</span>] <span style=color:#f92672>===</span> <span style=color:#e6db74>&#34;string&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This is a pretty loose definition however, and one can easily imagine
real-world examples for objects with these properties that are not
errors. So why not also check for <code>stack</code>? The problem with that is that the string representation of that stack
trace is created lazily when it is accessed. So checking for the <code>stack</code> attribute to find out if
something is an <code>Error</code> is about 8.5 times slower<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup> than just checking <code>name</code> and <code>message</code>.</p><h3 id=summary-table>Summary Table<a href=#summary-table class=hanchor arialabel=Anchor>&#8983;</a></h3><p>In the following table, more ✓s are always better:</p><table><thead><tr><th>Method</th><th>No False Positives</th><th>No False Negatives</th><th>Is Isomorphic</th><th>Not Deprecated</th></tr></thead><tbody><tr><td>Object.prototype.toString.call()</td><td>⤬</td><td>⤬</td><td>✓</td><td>⤬</td></tr><tr><td>util.types.isNativeError()</td><td>✓</td><td>⤬</td><td>⤬</td><td>✓</td></tr><tr><td>instanceof Error</td><td>✓</td><td>⤬</td><td>✓</td><td>✓</td></tr><tr><td>X.constructor.name === &ldquo;Error&rdquo;</td><td>⤬</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>checking for message and name</td><td>⤬</td><td>✓</td><td>✓</td><td>✓</td></tr></tbody></table><h2 id=using-combinations-of-several-checks>Using Combinations of several checks<a href=#using-combinations-of-several-checks class=hanchor arialabel=Anchor>&#8983;</a></h2><p><em>Using combinations of the methods described above is generally the way
to go.</em> Node.js itself uses <a href=https://github.com/nodejs/node/blob/3c0131a4190a88211780dcc07dbaf84c8de97f34/lib/internal/util.js#L95>this
function</a>
for checking if something is an <code>Error</code> internally:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>isError</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// An error could be an instance of Error while not being a native error
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// or could be from a different realm and not be instance of Error but still
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>// be a native error.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>isNativeError</span>(<span style=color:#a6e22e>e</span>) <span style=color:#f92672>||</span> <span style=color:#a6e22e>e</span> <span style=color:#66d9ef>instanceof</span> Error;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>While this is better than using only one of the methods, it still can
produce false negatives, if the error was created in another realm and
is not a native error:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>context</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>createContext</span>({});
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>myError</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>vm</span>.<span style=color:#a6e22e>runInContext</span>(<span style=color:#e6db74>&#39;new AxiosError()&#39;</span>, <span style=color:#a6e22e>context</span>); <span style=color:#75715e>// creates an error in a different realm
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>isError</span>(<span style=color:#a6e22e>myError</span>); <span style=color:#75715e>// returns false
</span></span></span></code></pre></div><p>Node.js&rsquo;s deprecated
<a href=https://nodejs.org/api/util.html#utiliserrorobject><code>util.isError()</code></a>
function uses a combination of <code>instanceof</code> and
<code>Object.prototype.toString.call()</code>. This makes it deprecated but
isomorphic.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>isError</span>(<span style=color:#a6e22e>e</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> Object.<span style=color:#a6e22e>prototype</span>.<span style=color:#a6e22e>toString</span>.<span style=color:#a6e22e>call</span>(<span style=color:#a6e22e>e</span>) <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;[object Error]&#39;</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>e</span> <span style=color:#66d9ef>instanceof</span> Error;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>And finally, as already mentioned above, undici uses <code>instanceof</code> and
constructor names. This makes it work across realms and does not use
Node.js-only functions. It will also produce less false positives than
just checking for the <code>name</code> and <code>message</code> properties. It is also fast
because the <code>||</code> short-circuits it to an <code>instanceof</code> test in many cases:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-JavaScript data-lang=JavaScript><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>isError</span> (<span style=color:#a6e22e>object</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>object</span> <span style=color:#66d9ef>instanceof</span> Error <span style=color:#f92672>||</span> (
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>object</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>constructor</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;Error&#39;</span> <span style=color:#f92672>||</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>object</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>constructor</span><span style=color:#f92672>?</span>.<span style=color:#a6e22e>name</span> <span style=color:#f92672>===</span> <span style=color:#e6db74>&#39;DOMException&#39;</span>
</span></span><span style=display:flex><span>    )
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>This code is taken from
<a href=https://github.com/nodejs/undici/blob/4885b11dd60b4d1a785c4e5a519ad87920549d1c/lib/fetch/util.js#L75>undici</a>.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>An <code>[[ErrorData]]</code> <a href=https://tc39.es/ecma262/#sec-object-internal-methods-and-internal-slots>internal
slot</a>
is used for this.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p><code>DOMException</code>s don&rsquo;t fit into the JavaScript naming scheme for errors. In JavaScript an exception is what happens if an
error is thrown.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>A realm is a JavaScript execution context which has its own global environment. If an error comes from another realm, its prototype points
to the <code>Error</code> prototype of the realm it was created in. Thus,<code>instanceof Error</code> will return <code>false</code>.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>I did some micro benchmarking to find this out. The exact number may depend on the use-case but it is <strong>a lot</strong> slower in any case.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2023 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>